<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>课堂连线题（简洁版）</title>
  <style>
    :root{--bg:#0b1020;--panel:#121a33;--accent:#6aa3ff;--good:#19d38a;--bad:#ff6b6b}
    *{box-sizing:border-box} body{margin:0;background:linear-gradient(120deg,#0b1020,#141b38);color:#e9eefc;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    header{padding:14px 18px;border-bottom:1px solid #233055;background:rgba(18,26,51,.7);backdrop-filter:blur(6px);position:sticky;top:0;z-index:10}
    h1{font-size:18px;margin:0}
    .wrap{max-width:1000px;margin:14px auto;padding:0 14px}
    .board{display:grid;grid-template-columns:1fr 1fr;gap:14px;position:relative}
    .col{background:var(--panel);border:1px solid #22305a;border-radius:16px;padding:12px}
    .col h2{margin:4px 0 10px 8px;font-size:14px;color:#c9d6fb;font-weight:600}
    .item{padding:10px 12px;margin:8px;border-radius:12px;border:1px solid #2a3a6e;background:#0f1630;cursor:pointer;user-select:none;line-height:1.25;transition:transform .06s ease,border .1s ease}
    .item:hover{transform:translateY(-1px)}
    .item.selected{outline:2px solid var(--accent);border-color:var(--accent)}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;margin:14px 0}
    .btn{background:#18224a;border:1px solid #2a3a6e;color:#e9eefc;padding:8px 12px;border-radius:12px;cursor:pointer;font-weight:600}
    .score{margin-left:auto;color:#cfe2ff;font-weight:600}
    svg#wires{position:absolute;inset:0;pointer-events:none;display:block}
    @media (max-width:760px){.board{grid-template-columns:1fr} .score{margin-left:0}}
  </style>
</head>
<body>
  <header><h1>课堂连线题（题目 / 答案）</h1></header>
  <div class="wrap">
    <div class="toolbar">
      <button class="btn" id="btnCheck">判分</button>
      <button class="btn" id="btnReset">重置</button>
      <div class="score" id="score">得分：0 / 0</div>
    </div>
    <div class="board" id="board">
      <div class="col"><h2>题目（左列）</h2><div id="leftList"></div></div>
      <div class="col"><h2>答案（右列）</h2><div id="rightList"></div></div>
      <svg id="wires" width="0" height="0"></svg>
    </div>
  </div>

<script>
// ======= 只显示题目+答案的简洁版，并修复“无法连线”的问题 =======
(function(){
  // 1) 在这里修改你的题目：left ↔ right 一一对应
  const DATA = [
    {left:'资产（Assets）', right:'受企业控制、预期带来经济利益的资源'},
    {left:'负债（Liabilities）', right:'需以经济利益转移清偿的现时义务'},
    {left:'收入（Revenue）', right:'日常活动形成、导致所有者权益增加的流入'},
    {left:'费用（Expense）', right:'日常活动发生、导致所有者权益减少的流出'},
    {left:'IFRS 15', right:'客户合同收入确认'}
  ];

  const leftList = document.getElementById('leftList');
  const rightList = document.getElementById('rightList');
  const board = document.getElementById('board');
  const wires = document.getElementById('wires');
  const scoreEl = document.getElementById('score');

  let items = [];           // [{id, left, right}]
  let leftOrder = [];       // [id]
  let rightOrder = [];      // [id]
  let connections = {};     // idLeft -> idRight
  let checked = false;

  const randId = () => Math.random().toString(36).slice(2,9);
  const shuffle = arr => [...arr].sort(()=>Math.random()-.5);

  function ensureSVGSize(){
    // 关键修复：给 SVG 设置与容器一致的宽高，否则有些浏览器无法正确绘制连线
    const bb = board.getBoundingClientRect();
    wires.setAttribute('width', bb.width);
    wires.setAttribute('height', bb.height);
  }

  function render(){
    items = DATA.map(p=>({id:randId(), left:String(p.left), right:String(p.right)}));
    leftOrder = items.map(x=>x.id);
    rightOrder = shuffle(items.map(x=>x.id));
    leftList.innerHTML = ''; rightList.innerHTML = ''; wires.innerHTML = '';
    checked = false; connections = {}; scoreEl.textContent = `得分：0 / ${items.length}`;

    for(const id of leftOrder){
      const it = items.find(x=>x.id===id);
      const el = document.createElement('div');
      el.className='item'; el.dataset.id=id; el.dataset.side='L'; el.textContent=it.left;
      leftList.appendChild(el);
    }
    for(const id of rightOrder){
      const it = items.find(x=>x.id===id);
      const el = document.createElement('div');
      el.className='item'; el.dataset.id=id; el.dataset.side='R'; el.textContent=it.right;
      rightList.appendChild(el);
    }

    bindClicks();
    ensureSVGSize();
    drawAll();
  }

  function drawLine(elL, elR, status){
    const bbL = elL.getBoundingClientRect();
    const bbR = elR.getBoundingClientRect();
    const boardBB = board.getBoundingClientRect();
    const x1 = (bbL.right - boardBB.left);
    const y1 = (bbL.top + bbL.height/2 - boardBB.top);
    const x2 = (bbR.left - boardBB.left);
    const y2 = (bbR.top + bbR.height/2 - boardBB.top);

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const dx = Math.max(30, Math.abs(x2-x1)/2);
    const d = `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
    path.setAttribute('d', d);
    // 直接使用固定色，避免 CSS 自定义变量在某些浏览器解析异常
    const color = status===true? '#19d38a' : status===false? '#ff6b6b' : '#6aa3ff';
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width','3');
    path.setAttribute('fill','none');
    path.style.filter='drop-shadow(0 0 3px rgba(106,163,255,.6))';
    wires.appendChild(path);
  }

  function drawAll(){
    wires.innerHTML='';
    ensureSVGSize();
    for(const [lId, rId] of Object.entries(connections)){
      const elL = leftList.querySelector(`.item[data-id="${lId}"]`);
      const elR = rightList.querySelector(`.item[data-id="${rId}"]`);
      if(elL && elR) drawLine(elL, elR, checked ? (lId===rId) : null);
    }
  }

  let selLeft = null;
  function bindClicks(){
    document.querySelectorAll('.item').forEach(el=>{
      el.addEventListener('click',()=>{
        if(checked) return; // 判分后锁定
        const side = el.dataset.side; const id = el.dataset.id;
        if(side==='L'){
          document.querySelectorAll('#leftList .item').forEach(x=>x.classList.remove('selected'));
          el.classList.add('selected'); selLeft = id;
        }else{
          // 如果该右项已被占用，释放
          const exist = Object.entries(connections).find(([l,r])=>r===id);
          if(exist) delete connections[exist[0]];
          if(selLeft){
            connections[selLeft] = id; selLeft = null;
            document.querySelectorAll('#leftList .item').forEach(x=>x.classList.remove('selected'));
            drawAll();
          }
        }
      });
    });
  }

  function checkScore(){
    let correct=0; for(const [l,r] of Object.entries(connections)) if(l===r) correct++;
    checked=true; scoreEl.textContent = `得分：${correct} / ${items.length}`; drawAll();
  }
  function resetAll(){ connections={}; checked=false; selLeft=null; scoreEl.textContent = `得分：0 / ${items.length}`; drawAll(); }

  document.getElementById('btnCheck').onclick = checkScore;
  document.getElementById('btnReset').onclick = resetAll;
  window.addEventListener('resize', drawAll);

  render();
})();
</script>
</body>
</html>
